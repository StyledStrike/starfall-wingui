--@name [Lib] WinGUI
--@author StyledStrike
--@client

--[[
    GUI library, inspired by the Windows 95 theme

    - Required permissions: "input"
]]

local WinGUI = {
    -- Mouse properties
    mouseX = 0,
    mouseY = 0,
    mouseLeft = false,

    -- Panels that can be instantiated
    registry = {},

    -- List of panel instances by id
    instances = {},

    -- List of panel instances to remove next frame
    remove = {}
}

do
    -- The "root" panel
    local root = {
        x = 0,
        y = 0,
        w = 1024,
        h = 576,

        _id = "root",
        _children = {},
        _visible = true
    }

    -- lets implement the basics to prevent errors
    WinGUI.root = root

    function root:InvalidateLayout()
        for _, c in ipairs( self._children ) do
            c:InvalidateLayout()
        end
    end

    function root:GetAbsolutePos()
        return self.x, self.y
    end

    function root:ScreenToLocal( x, y )
        return x - self.x, y - self.y
    end
end

-- Theme colors
local COLORS = {
    black = Color( 0, 0, 0 ),
    white = Color( 255, 255, 255 ),
    darkGray = Color( 135, 136, 143 ),
    lightGray = Color( 192, 199, 200 ),
    primary = Color( 0, 0, 168 ),
    scroll = Color( 227, 230, 230 )
}

WinGUI.COLORS = COLORS

-- Theme fonts
local FONTS = {
    icons = "Marlett",
    title = "TargetIDSmall",
    text = "HudSelectionText"
}

WinGUI.FONTS = FONTS

-- Panel docking modes
local DOCK = {
    NODOCK = 0,
    LEFT = 1,
    RIGHT = 2,
    TOP = 3,
    BOTTOM = 4,
    FILL = 5
}

WinGUI.DOCK = DOCK

-- Content alignment for labels and derivates
local CONTENT_ALIGN = {
    BOTTOM_LEFT = 1,
    BOTTOM_CENTER = 2,
    BOTTOM_RIGHT = 3,
    MIDDLE_LEFT = 4,
    CENTER = 5,
    MIDDLE_RIGHT = 6,
    TOP_LEFT = 7,
    TOP_CENTER = 8,
    TOP_RIGHT = 9
}

WinGUI.CONTENT_ALIGN = CONTENT_ALIGN

hook.add( "think", "WinGUI.Update", function()
    if hasPermission( "input" ) then
        WinGUI:Think()
    end
end )

hook.add( "mouseWheeled", "WinGUI.DetectMouseWheel", function( delta )
    if WinGUI.isUsingScreen or ( render.isHUDActive() and input.getCursorVisible() ) then
        WinGUI:OnMouseWheel( delta, WinGUI.mouseX, WinGUI.mouseY )
    end
end )

local EnableScissor = render.enableScissorRect
local DisableScissor = render.disableScissorRect

--- A placeholder function that does nothing.
local function NOOP() end

--- Make sure that `value`'s type is the `expectedType`, otherwise throws a error.
local function AssertType( value, name, expectedType )
    assert( type( value ) == expectedType, string.format( "%s: expected %s, got %s", name, expectedType, type( value ) ) )
end

--- Checks if a screen position is inside of this panel's clickable area.
local function IsPanelClickable( p, x, y )
    local b = p._clickableBounds
    return x > b[1] and y > b[2] and x < b[3] and y < b[4]
end

-- Calls OnUnfocus on this panel and on all of its children.
local function UnfocusPanelAndChildren( p )
    if p.OnUnfocus then
        p:OnUnfocus()
    end

    if p._children then
        for _, c in ipairs( p._children ) do
            UnfocusPanelAndChildren( c )
        end
    end
end

--- Make WinGUI work on Starfall screens.
function WinGUI:EnableScreenMode( resolutionW, resolutionH )
    render.createRenderTarget( "desktop" )

    -- Desktop resolution
    self.resolutionW = math.clamp( resolutionW or 1024, 256, 1024 )
    self.resolutionH = math.clamp( resolutionH or 576, 256, 1024 )

    self.isUsingScreen = true
    self:SetChatInputEnabled( true )
    self:ConfigureDesktop( 0, 0, self.resolutionW, self.resolutionH )

    local SetStencilEnable = render.setStencilEnable

    DisableScissor = function()
        SetStencilEnable( false )
    end

    local ResetStencil = render.resetStencil
    local SetStencilReferenceValue = render.setStencilReferenceValue
    local SetStencilCompareFunction = render.setStencilCompareFunction
    local SetStencilFailOperation = render.setStencilFailOperation
    local ClearStencilBufferRectangle = render.clearStencilBufferRectangle

    EnableScissor = function( x, y, w, h )
        ResetStencil()
        SetStencilEnable( true )

        SetStencilReferenceValue( 1 )
        SetStencilCompareFunction( 1 )
        SetStencilFailOperation( STENCIL.REPLACE )
        ClearStencilBufferRectangle( x, y, w, h, 1 )

        SetStencilCompareFunction( STENCIL.EQUAL )
        SetStencilFailOperation( STENCIL.KEEP )
    end
end

--- Set the desktop dimensions.
function WinGUI:ConfigureDesktop( x, y, w, h )
    self.root.x = math.max( x, 0 )
    self.root.y = math.max( y, 0 )
    self.root.w = math.max( w, 256 )
    self.root.h = math.max( h, 256 )
    self.root:InvalidateLayout()
end

--- Create and register a panel table that can be instantiated later.
function WinGUI:Register( class, parentClass )
    AssertType( class, "class", "string" )
    assert( self.registry[class] == nil, "Panel class already exists: " .. class )

    local panel = {}

    if parentClass then
        AssertType( parentClass, "parentClass", "string" )
        assert( self.registry[parentClass], "Parent panel class does not exist: " .. parentClass )
        setmetatable( panel, self.registry[parentClass] )
    end

    panel.__index = panel
    self.registry[class] = panel

    return panel
end

--- Instantiate a panel.
function WinGUI:Create( class, parent )
    parent = parent or self.root

    assert( self.registry[class], "Panel class does not exist: " .. class )
    AssertType( parent, "parent", "table" )

    if parent._id ~= "root" then
        assert( parent._id, "Invalid parent" )
        assert( self.instances[parent._id], "Parent does not exist" )
    end

    local instance = {
        x = 0,
        y = 0,
        w = 20,
        h = 20,
        _id = "",
        _class = class,
        _parent = parent,
        _visible = true,
        _isLayoutInvalid = true
    }

    -- Assign a unique id
    instance._id = table.address( instance )

    -- Make the parent remember this panel as one of it's children
    parent._children = parent._children or {}
    parent._children[#parent._children + 1] = instance

    -- Make this instance use the class' fields and methods
    setmetatable( instance, self.registry[class] )

    self.instances[instance._id] = instance

    if instance.Setup then
        instance:Setup()
    end

    parent:InvalidateLayout()

    return instance
end

--- Check if a panel is not nil and has not been removed yet.
function WinGUI:IsValid( panel )
    return panel ~= nil and self.instances[panel._id] ~= nil
end

--- Marks a panel instance and its children for removal next frame.
function WinGUI:Remove( panel )
    local function GetPanelAndChildren( p )
        self.remove[p] = true

        if not p._children then return end

        for _, child in ipairs( p._children ) do
            GetPanelAndChildren( child )
        end
    end

    GetPanelAndChildren( panel )
end

local Clamp = math.clamp

do
    local contextMenu

    function WinGUI:CloseContextMenu()
        if self:IsValid( contextMenu ) then
            self:Remove( contextMenu )
            contextMenu = nil
        end
    end

    --- Creates a panel that is automatically removed
    --- when the mouse clicks anywhere else on the screen.
    function WinGUI:OpenContextMenu( x, y, w, h )
        self:CloseContextMenu()

        x, y = self.root:ScreenToLocal( x or self.mouseX, y or self.mouseY )
        w, h = w or 100, h or 70

        -- dont let the menu go off screen
        local l, t, r, b = self.root.x, self.root.y, self.root.w, self.root.h

        x = Clamp( x, l, r - w )
        y = Clamp( y, t, b - h )

        contextMenu = self:Create( "Panel" )
        contextMenu:SetDimensions( x, y, w, h )
        contextMenu:MakePopup( false )

        contextMenu.OnUnfocus = function()
            self:CloseContextMenu()
        end

        return contextMenu
    end
end

local PushClipping, PopClipping
local RealTime = timer.realtime

do
    -- Remember the order in which things were drawn.
    -- Used to find out which panel was clicked.
    local drawOrder = {}

    -- The panel the cursor is pressing on
    local holdingPanel

    -- Current text entry we are typing into
    local focusedEntry

    -- Repeat keys while they are being held down
    local repeatKey, repeatTimer

    function WinGUI:OnKeyPress( key )
        repeatKey = key
        repeatTimer = RealTime() + 0.3

        if focusedEntry and focusedEntry.OnKeyPress then
            focusedEntry:OnKeyPress( key )
        else
            local p

            for i = #drawOrder, 1, -1 do
                p = drawOrder[i]

                if p.OnKeyCodePressed and p:OnKeyCodePressed( key ) then
                    break
                end
            end
        end
    end

    --- Finds the first clickable panel under a certain position.
    function WinGUI:GetPanelAt( x, y )
        local p

        for i = #drawOrder, 1, -1 do
            p = drawOrder[i]

            if IsPanelClickable( p, x, y ) then
                return p
            end
        end
    end

    --- Set the currently focused text entry panel (or derivatives).
    function WinGUI:FocusOnEntry( panel )
        if self:IsValid( focusedEntry ) and focusedEntry.OnUnfocus then
            focusedEntry:OnUnfocus()
        end

        focusedEntry = panel

        if panel and panel.OnFocus then
            panel:OnFocus()
        end
    end

    --- Set if WinGUI should use the chat box for text input.
    function WinGUI:SetChatInputEnabled( enable )
        self.useChatInput = enable
        self.isChatOpen = false
        self:FocusOnEntry( nil )

        repeatKey = nil
        repeatTimer = 0

        hook.remove( "inputPressed", "WinGUI.DetectKeys" )
        hook.remove( "StartChat", "WinGUI.DetectChatOpen" )
        hook.remove( "FinishChat", "WinGUI.DetectChatClose" )
        hook.remove( "ChatTextChanged", "WinGUI.UpdateText" )

        if input.isControlLocked() then
            input.lockControls( false )
        end

        if enable then
            hook.add( "StartChat", "WinGUI.DetectChatOpen", function()
                self.isChatOpen = true

                hook.add( "ChatTextChanged", "WinGUI.UpdateText", function( text )
                    if focusedEntry and focusedEntry.OnKeyPress then
                        focusedEntry.value = text
                        focusedEntry._caret = text:len()
                    end
                end )
            end )

            hook.add( "FinishChat", "WinGUI.DetectChatClose", function()
                self.isChatOpen = false

                hook.remove( "ChatTextChanged", "WinGUI.UpdateText" )
            end )
        else
            hook.add( "inputPressed", "WinGUI.DetectKeys", function( key )
                if render.isHUDActive() then
                    WinGUI:OnKeyPress( key )
                end
            end )
        end
    end

    WinGUI:SetChatInputEnabled( false )

    --- Recursively update the layout of this panel and its children.
    local function UpdateLayout( p )
        if not p._visible then return end

        if p._isLayoutInvalid then
            p._isLayoutInvalid = false
            p:PerformDock()
            p:PerformLayout()
        end

        if not p._children then return end

        for _, c in ipairs( p._children ) do
            UpdateLayout( c )
        end
    end

    --- Updates the mouse, keyboard and panel layouts.
    function WinGUI:Think()
        -- Take care of panels marked for removal now
        for p, _ in pairs( self.remove ) do
            local parent = p._parent

            -- Make sure the parent knows this panel is gone
            if parent._children then
                table.removeByValue( parent._children, p )
            end

            setmetatable( p, nil )
            self.instances[p._id] = nil
            self.remove[p] = nil
        end

        local mouseLeft

        if self.isUsingScreen then
            mouseLeft = not self.isChatOpen and input.isKeyDown( KEY.E )
        else
            mouseLeft = input.getCursorVisible() and input.isMouseDown( MOUSE.LEFT )

            self.mouseX, self.mouseY = input.getCursorPos()
        end

        if mouseLeft ~= self.mouseLeft then
            self.mouseLeft = mouseLeft

            if mouseLeft then
                self:MousePress( self.mouseX, self.mouseY )
            else
                self:MouseRelease()
            end
        end

        if mouseLeft and holdingPanel and holdingPanel.OnMouseDrag then
            holdingPanel:OnMouseDrag( self.mouseX, self.mouseY )
        end

        -- update the layout
        UpdateLayout( self.root )

        -- dont deal with input locking/repeat keys while using chat input or a screen
        if self.useChatInput or self.isUsingScreen then return end

        -- lock controls when using a entry
        if focusedEntry and not input.isControlLocked() and input.canLockControls() then
            input.lockControls( true )
        end

        -- repeat keys that are still being pressed
        if not repeatKey then return end

        local t = RealTime()

        if t > repeatTimer then
            if input.isKeyDown( repeatKey ) then
                if focusedEntry and focusedEntry.OnKeyPress then
                    focusedEntry:OnKeyPress( repeatKey )
                end

                repeatTimer = t + 0.03
            else
                repeatKey = nil
            end
        end
    end

    --- Handle mouse press events on panels.
    function WinGUI:MousePress( x, y )
        self:FocusOnEntry()

        local p

        for i = #drawOrder, 1, -1 do
            p = drawOrder[i]

            if p.OnMousePress and IsPanelClickable( p, x, y ) and p:OnMousePress( x, y ) then
                holdingPanel = p
                break
            end
        end

        if not holdingPanel then
            self:CloseContextMenu()

            UnfocusPanelAndChildren( self.root )

            return
        end

        -- Try to make popup the window in the chain
        local parent = holdingPanel._parent

        timer.simple( 0, function()
            if not self:IsValid( parent ) then return end

            while parent do
                if parent._class == "Window" then
                    parent:MakePopup()
                    break
                end

                parent = parent._parent
            end
        end )
    end

    --- Handle mouse release events on panels.
    function WinGUI:MouseRelease()
        if not holdingPanel then return end

        if holdingPanel.OnMouseRelease then
            holdingPanel:OnMouseRelease()
        end

        holdingPanel = nil
    end

    --- Handle mouse wheel events on panels.
    function WinGUI:OnMouseWheel( delta, x, y )
        local p

        for i = #drawOrder, 1, -1 do
            p = drawOrder[i]

            if p.OnMouseWheel and IsPanelClickable( p, x, y ) and p:OnMouseWheel( delta ) then
                break
            end
        end
    end

    -- Keeps the box's corners inside two coordinates.
    local function ClampBounds( l, t, r, b, minX, minY, maxX, maxY )
        l = Clamp( l, minX, maxX )
        t = Clamp( t, minY, maxY )
        r = Clamp( r, minX, maxX )
        b = Clamp( b, minY, maxY )

        return l, t, r, b
    end

    local stack = {}

    --- Pushes a clip to the stack, limiting the
    --- rendering to a confined space. This will
    --- obey the bounds of the last pushed clip.
    PushClipping = function( x, y, w, h )
        w = x + w
        h = y + h

        -- limit to a previous clip on the stack
        local previous = stack[#stack]

        if previous then
            x, y, w, h = ClampBounds( x, y, w, h, previous[1], previous[2], previous[3], previous[4] )
        end

        EnableScissor( x, y, w, h )
        stack[#stack + 1] = { x, y, w, h }
    end

    WinGUI.PushClipping = PushClipping

    --- Restores the previous clip if it exists,
    --- otherwise disables clipping entirely. 
    PopClipping = function()
        table.remove( stack )

        local clip = stack[#stack]

        if clip then
            EnableScissor( clip[1], clip[2], clip[3], clip[4] )
        else
            DisableScissor()
        end
    end

    WinGUI.PopClipping = PopClipping

    local drawCount = 0

    --- Recursively render this panel and its children.
    --- Also update where this panel can be clicked on depending on clipping.
    local function RenderPanel( p, x, y )
        x, y = x + p.x, y + p.y

        if p.Render then
            p:Render( x, y, p.w, p.h )

            -- update the panel's clickable area, while
            -- respecting the current render clipping
            local l, t, r, b = x, y, x + p.w, y + p.h
            local clip = stack[#stack]

            if clip then
                l, t, r, b = ClampBounds( l, t, r, b, clip[1], clip[2], clip[3], clip[4] )
            end

            p._clickableBounds = { l, t, r, b }

            drawCount = drawCount + 1
            drawOrder[drawCount] = p
        end

        if p._children then
            for _, c in ipairs( p._children ) do
                if c._visible then
                    RenderPanel( c, x, y )
                end
            end
        end

        if p.PostRender then
            p:PostRender()
        end
    end

    local clearColor = Color( 0, 0, 0, 0 )
    local textureColor = Color( 255, 255, 255, 255 )

    function WinGUI:Render()
        local w, h = render.getResolution()

        if self.isUsingScreen then
            local x, y = render.cursorPos()

            self.mouseX = ( ( x or 0 ) / w ) * self.resolutionW
            self.mouseY = ( ( y or 0 ) / h ) * self.resolutionH

            render.selectRenderTarget( "desktop" )
            render.clear( clearColor )
            render.resetStencil()
        end

        stack = {}
        drawOrder = {}
        drawCount = 0

        RenderPanel( self.root, 0, 0 )
        DisableScissor()

        if self.isUsingScreen then
            render.selectRenderTarget()

            render.setColor( textureColor )
            render.setRenderTargetTexture( "desktop" )
            render.drawTexturedRectUVFast( 0, 0, w, h, 0, 0, self.resolutionW / 1024, self.resolutionH / 1024, true )
        end
    end
end

local Max = math.max
local Floor = math.floor

local GetTextSize = render.getTextSize
local SetColor, DrawRect = render.setColor, render.drawRectFast

-------- Base Panel --------

local Panel = WinGUI:Register( "Panel" )

function Panel.__tostring( self )
    return self._class .. " <" .. self._id .. ">"
end

function Panel:Setup() end

--- Marks this panel and its children for removal next frame.
function Panel:Remove()
    WinGUI:Remove( self )
end

--- Returns the screen position of this panel.
function Panel:GetAbsolutePos()
    local x, y = self._parent:GetAbsolutePos()
    return x + self.x, y + self.y
end

--- Convert a screen position to a position local to this panel.
function Panel:ScreenToLocal( x, y )
    local myX, myY = self:GetAbsolutePos()
    return x - myX, y - myY
end

--- Removes all children of this panel.
function Panel:Clear()
    if not self._children then return end

    local count = #self._children

    for i = count, 1, -1 do
        self._children[i]:Remove()
    end

    self._children = nil
    self:InvalidateLayout()
end

--- Set if this panel should be rendered and be clickable.
function Panel:SetVisible( visible )
    self._visible = visible

    if visible then
        self:InvalidateLayout()
    end
end

--- Marks this panel and its children with a invalid layout flag.
function Panel:InvalidateLayout()
    self._isLayoutInvalid = true

    if self._children then
        for _, c in ipairs( self._children ) do
            c:InvalidateLayout()
        end
    end
end

--- Calculates the limits of this panel bounds based on its parent.
function Panel:GetBoundsFromParent()
    local l, t = 0, 0
    local r, b = self._parent.w, self._parent.h
    local parentPadding = self._parent._dockPadding

    if parentPadding then
        l = parentPadding.l
        t = parentPadding.t
        r = self._parent.w - parentPadding.r
        b = self._parent.h - parentPadding.b
    end

    return l, t, r, b
end

--- Set this panel's position and size.
--- It's limited to stay inside the parent.
function Panel:SetDimensions( x, y, w, h )
    local l, t, r, b = self:GetBoundsFromParent()

    self.x = Clamp( x, l, r - self.w )
    self.y = Clamp( y, t, b - self.h )

    self.w = Clamp( w, 0, r - self.x )
    self.h = Clamp( h, 0, b - self.y )

    self:InvalidateLayout()
end

--- Set this panel's size to the total size of its children.
--- The sizeW and sizeH parameters are false by default, therefore,
--- calling this function with no arguments will do nothing besides invalidate the layout.
function Panel:SizeToChildren( sizeW, sizeH )
    local totalW, totalH = 0, 0
    local padding = self._dockPadding

    if padding then
        totalW = totalW + padding.l + padding.r
        totalH = totalH + padding.t + padding.b
    end

    if self._children then
        for _, p in ipairs( self._children ) do
            totalW = totalW + p.w
            totalH = totalH + p.h

            local m = p._dockMargin

            if m then
                totalW = totalW + m.l + m.r
                totalH = totalH + m.t + m.b
            end
        end
    end

    self.w = sizeW and totalW or self.h
    self.h = sizeH and totalH or self.h
    self:InvalidateLayout()
end

--- Fixate the panel to a certain location on it's parent.
function Panel:Dock( mode )
    if mode == DOCK.NODOCK then
        mode = nil
    end

    self._dock = mode
    self._parent:InvalidateLayout()
end

--- Set the margins when docking the panel.
function Panel:DockMargin( l, t, r, b )
    self._dockMargin = {
        l = l,
        t = t,
        r = r,
        b = b
    }

    self._parent:InvalidateLayout()
end

--- Set the margins when docking this panel's children.
function Panel:DockPadding( l, t, r, b )
    self._dockPadding = {
        l = l,
        t = t,
        r = r,
        b = b
    }

    self:InvalidateLayout()
end

--- Update the docking of all children, right before `PerformLayout`.
function Panel:PerformDock()
    if not self._children then return end

    -- remaining area to fill
    local l, t = 0, 0
    local r, b = self.w, self.h

    if self._dockPadding then
        l = self._dockPadding.l
        t = self._dockPadding.t
        r = self.w - self._dockPadding.r
        b = self.h - self._dockPadding.b
    end

    -- margins
    local ml, mt, mr, mb

    for _, p in ipairs( self._children ) do
        if p._dock then
            local mode = p._dock

            ml, mt, mr, mb = 0, 0, 0, 0

            if p._dockMargin then
                ml = p._dockMargin.l
                mt = p._dockMargin.t
                mr = p._dockMargin.r
                mb = p._dockMargin.b
            end

            if mode == DOCK.FILL or mode == DOCK.TOP or mode == DOCK.BOTTOM then
                p.w = Max( 0, ( r - l ) - ml - mr )
            end

            if mode == DOCK.FILL or mode == DOCK.LEFT or mode == DOCK.RIGHT then
                p.h = Max( 0, ( b - t ) - mt - mb )
            end

            if mode == DOCK.RIGHT then
                p.x = r - p.w - mr
                p.y = t + mt
                r = p.x - ml

            elseif mode == DOCK.LEFT then
                p.x = l + ml
                p.y = t + mt
                l = p.x + p.w + mr

            elseif mode == DOCK.BOTTOM then
                p.x = l + ml
                p.y = b - p.h - mb
                b = p.y - mt

            elseif mode == DOCK.TOP then
                p.x = l + ml
                p.y = t + mt
                t = p.y + p.h + mb

            else
                p.x = l + ml
                p.y = t + mt
            end
        end
    end
end

--- Called whenever the panel's layout needs to be updated.
function Panel:PerformLayout() end

--- Bring a panel to the end of it's parent's
--- children list, thus placing it in the front.
function Panel:MakePopup( unfocusOthers )
    -- take ourselves out from the parent's child list
    table.removeByValue( self._parent._children, self )

    if unfocusOthers then
        -- let all other children know they are being unfocused
        UnfocusPanelAndChildren( self._parent )
    end

    -- then add ourselves back at the end
    table.insert( self._parent._children, self )
end

function Panel:RenderPressed( x, y, w, h )
    SetColor( COLORS.white )
    DrawRect( x, y, w, h )

    SetColor( COLORS.darkGray )
    DrawRect( x, y, w - 1, h - 1 )

    SetColor( COLORS.black )
    DrawRect( x + 1, y + 1, w - 2, h - 2 )

    SetColor( COLORS.lightGray )
    DrawRect( x + 2, y + 2, w - 3, h - 3 )
end

function Panel:Render( x, y, w, h )
    SetColor( COLORS.black )
    DrawRect( x, y, w, h )

    SetColor( COLORS.white )
    DrawRect( x, y, w - 1, h - 1 )

    SetColor( COLORS.darkGray )
    DrawRect( x + 1, y + 1, w - 2, h - 2 )

    SetColor( COLORS.lightGray )
    DrawRect( x + 1, y + 1, w - 3, h - 3 )
end

function Panel:RenderInput( x, y, w, h, backgroundColor )
    SetColor( COLORS.white )
    DrawRect( x, y, w, h )

    SetColor( COLORS.darkGray )
    DrawRect( x, y, w - 1, h - 1 )

    SetColor( COLORS.lightGray )
    DrawRect( x + 1, y + 1, w - 2, h - 2 )

    SetColor( COLORS.black )
    DrawRect( x + 1, y + 1, w - 3, h - 3 )

    SetColor( backgroundColor or COLORS.white )
    DrawRect( x + 2, y + 2, w - 4, h - 4 )
end

-------- Label --------

local SetFont = render.setFont
local DrawSimpleText = render.drawSimpleText

local Label = WinGUI:Register( "Label", "Panel" )

function Label:Setup()
    self.text = "Label"
    self.font = FONTS.text
    self.textColor = Color( 0, 0, 0 )
    self.backgroundColor = nil
    self.h = 16

    self._alignX = TEXT_ALIGN.LEFT
    self._alignY = TEXT_ALIGN.TOP
    self._alignment = CONTENT_ALIGN.TOP_LEFT
    self._padding = 0
    self._offsetX = 0
    self._offsetY = 0
end

--- Set the alignment of the label's contents.
function Label:SetContentAlignment( alignment, padding )
    self._alignment = alignment
    self._padding = padding or 0
    self:InvalidateLayout()
end

function Label:PerformLayout()
    local alignment = self._alignment - 1
    local alignH = alignment % 3
    local alignV = Floor( alignment / 3 )
    local w, h = self.w, self.h

    if alignH == 0 then
        self._alignX = TEXT_ALIGN.LEFT
        self._offsetX = self._padding

    elseif alignH == 1 then
        self._alignX = TEXT_ALIGN.CENTER
        self._offsetX = w * 0.5

    else
        self._alignX = TEXT_ALIGN.RIGHT
        self._offsetX = w - self._padding
    end

    if alignV == 0 then
        self._alignY = TEXT_ALIGN.BOTTOM
        self._offsetY = h - self._padding

    elseif alignV == 1 then
        self._alignY = TEXT_ALIGN.CENTER
        self._offsetY = ( h * 0.5 ) - 1

    else
        self._alignY = TEXT_ALIGN.TOP
        self._offsetY = self._padding
    end
end

function Label:Render( x, y, w, h )
    if self.backgroundColor then
        SetColor( self.backgroundColor )
        DrawRect( x, y, w, h )
    end

    SetColor( self.textColor )
    SetFont( self.font )
    DrawSimpleText( x + self._offsetX, y + self._offsetY, self.text, self._alignX, self._alignY )
end

-------- Button --------

local Button = WinGUI:Register( "Button", "Label" )

function Button:Setup()
    Label.Setup( self )

    self.h = 23
    self:SetContentAlignment( CONTENT_ALIGN.CENTER )
end

function Button:Render( x, y, w, h )
    if self.isPressed then
        Panel.RenderPressed( self, x, y, w, h )
    else
        Panel.Render( self, x, y, w, h )
    end

    Label.Render( self, x, y, w, h )
end

function Button:OnMousePress()
    self.isPressed = true

    return true
end

function Button:OnMouseRelease()
    self.isPressed = false

    if self.OnClick and IsPanelClickable( self, WinGUI.mouseX, WinGUI.mouseY ) then
        self.OnClick()
    end
end

-------- Progress Bar --------

local ProgressBar = WinGUI:Register( "ProgressBar", "Panel" )

function ProgressBar:Setup()
    self.value = 0
end

function ProgressBar:Render( x, y, w, h )
    Panel.RenderPressed( self, x, y, w, h )

    w = ( w - 2 ) * Clamp( self.value, 0, 1 )

    SetColor( COLORS.primary )
    DrawRect( x + 1, y + 2, w, h - 3 )
end

-------- Horizontal Slider --------

local HSlider = WinGUI:Register( "HSlider", "Panel" )

function HSlider:Setup()
    self.h = 24
    self.value = 0
    self.minValue = 0
    self.maxValue = 1
    self._buttonWidth = 10
end

function HSlider:Render( x, y, w, h )
    local buttonW = self._buttonWidth
    local trackx = x + buttonW * 0.5
    local tracky = y + Floor( h * 0.5 ) - 1
    local trackw = w - buttonW

    SetColor( COLORS.white )
    DrawRect( trackx, tracky, trackw, 4 )

    SetColor( COLORS.darkGray )
    DrawRect( trackx, tracky, trackw - 1, 3 )

    SetColor( COLORS.lightGray )
    DrawRect( trackx + 1, tracky + 1, trackw - 2, 2 )

    SetColor( COLORS.black )
    render.drawLine( trackx + 1, tracky + 1, trackx + trackw - 2, tracky + 1 )

    x = x + Clamp( ( self.value - self.minValue ) / ( self.maxValue - self.minValue ), 0, 1 ) * trackw

    Panel.Render( self, x, y + 2, buttonW, h - 4 )
end

function HSlider:OnMousePress()
    return true
end

function HSlider:OnMouseDrag( x )
    local lx = self:ScreenToLocal( x, 0 )
    local value = ( lx - ( self._buttonWidth * 0.5 ) ) / ( self.w - self._buttonWidth )

    self.value = self.minValue + ( self.maxValue - self.minValue ) * Clamp( value, 0, 1 )

    if self.OnChange then
        self.OnChange( self.value )
    end
end

-------- Check Box --------

local CheckBox = WinGUI:Register( "CheckBox", "Label" )

function CheckBox:Setup()
    Label.Setup( self )

    self.w = 13
    self.h = 13
    self.value = false

    self:SetContentAlignment( CONTENT_ALIGN.MIDDLE_LEFT )
end

function CheckBox:Render( x, y, w, h )
    if self.backgroundColor then
        SetColor( self.backgroundColor )
        DrawRect( x, y, w, h )
    end

    SetColor( COLORS.white )
    DrawRect( x, y, h, h )

    SetColor( COLORS.darkGray )
    DrawRect( x, y, h - 1, h - 1 )

    SetColor( COLORS.lightGray )
    DrawRect( x + 1, y + 1, h - 2, h - 2 )

    SetColor( COLORS.black )
    DrawRect( x + 1, y + 1, h - 3, h - 3 )

    SetColor( COLORS.white )
    DrawRect( x + 2, y + 2, h - 4, h - 4 )

    SetColor( self.textColor )
    SetFont( self.font )
    DrawSimpleText( x + h + 2 + self._offsetX, y + self._offsetY, self.text, self._alignX, self._alignY )

    if self.value then
        SetColor( COLORS.black )
        render.drawLine( x + 3, y + h * 0.5, x - 1 + h * 0.5, y + h - 4 )
        render.drawLine( x - 1 + h * 0.5, y + h - 4, x + h - 3, y + 4 )
    end
end

function CheckBox:OnMousePress()
    self.value = not self.value

    if self.OnChange then
        self.OnChange( self.value )
    end

    return true
end

-------- Combo Box --------

local ComboBox = WinGUI:Register( "ComboBox", "Panel" )

function ComboBox:Setup()
    self._text = nil
    self.placeholder = "..."
    self.font = FONTS.text
    self.textColor = Color( 0, 0, 0 )
    self.backgroundColor = nil
    self.h = 21

    self:Clear()

    local downButton = WinGUI:Create( "Button", self )
    downButton.y = 2
    downButton.w = 16
    downButton.text = "6"
    downButton.font = FONTS.icons
    downButton:SetContentAlignment( CONTENT_ALIGN.CENTER )

    downButton.OnClick = function()
        self:OnMousePress()
    end

    self.downButton = downButton
end

function ComboBox:Clear()
    self._options = {}
    self._selected = nil
    self._text = nil
end

function ComboBox:AddOption( text, shouldSelect )
    local index = #self._options + 1

    self._options[index] = text

    if shouldSelect then
        self:SelectOption( index )
    end
end

function ComboBox:SelectOption( index )
    if not index or not self._options[index] then
        self._selected = nil
        self._text = nil

        return
    end

    self._selected = index
    self._text = self._options[index]

    if self.OnSelect then
        self.OnSelect( index, self._text )
    end
end

function ComboBox:PerformLayout()
    self.downButton.x = self.w - self.downButton.w - 2
    self.downButton.h = self.h - 4
end

function ComboBox:OnMousePress()
    local x, y = self:GetAbsolutePos()
    local menu = WinGUI:OpenContextMenu( x, y + self.h, math.min( self.w, 400 ), 100 )
    menu.Render = NOOP

    local list = WinGUI:Create( "SimpleList", menu )
    list:Dock( DOCK.FILL )

    for i, v in ipairs( self._options ) do
        list:AddLine( v, i == self._selected )
    end

    list.OnSelect = function( index )
        WinGUI:CloseContextMenu()
        self:SelectOption( index )
    end

    return true
end

function ComboBox:Render( x, y, w, h )
    Panel.RenderInput( self, x, y, w, h, self.backgroundColor )

    SetFont( self.font )
    SetColor( self._text and self.textColor or COLORS.darkGray )
    DrawSimpleText( x + 4, y + h * 0.5, self._text or self.placeholder, TEXT_ALIGN.LEFT, TEXT_ALIGN.CENTER )
end

-------- Vertical Scroll Bar --------

local VScrollBar = WinGUI:Register( "VScrollBar", "Panel" )

function VScrollBar:Setup()
    self.w = 16
    self.offset = 0
    self.isDragging = false

    self._scroll = 0
    self._viewSize = 1
    self._scrollSize = 2
    self._scrollPos = 0
    self._gripSize = 0
    self._buttonSize = 16

    local upButton = WinGUI:Create( "Button", self )
    upButton.w = self._buttonSize
    upButton.h = self._buttonSize
    upButton.text = "5"
    upButton.font = FONTS.icons
    upButton:SetContentAlignment( CONTENT_ALIGN.CENTER )

    local downButton = WinGUI:Create( "Button", self )
    downButton.w = self._buttonSize
    downButton.h = self._buttonSize
    downButton.text = "6"
    downButton.font = FONTS.icons
    downButton:SetContentAlignment( CONTENT_ALIGN.CENTER )

    upButton.OnClick = function()
        self:SetScroll( self._scroll - 25 )
    end

    downButton.OnClick = function()
        self:SetScroll( self._scroll + 25 )
    end

    self.upButton = upButton
    self.downButton = downButton
end

--- Configure how large the canvas is, and it's viewing window.
function VScrollBar:SetCanvas( viewSize, canvasSize )
    self._viewSize = viewSize
    self._scrollSize = Max( canvasSize - viewSize, 1 )
    self:SetScroll( self._scroll )
end

--- Set and validate the scroll position.
function VScrollBar:SetScroll( offset )
    self._scroll = Clamp( offset, 0, self._scrollSize )
    self:InvalidateLayout()

    if self.OnScroll then
        self.OnScroll( self._scroll )
    end
end

function VScrollBar:PerformLayout()
    self.downButton.y = self.h - self._buttonSize

    local offset = self._scroll / self._scrollSize
    local trackSize = self.h - ( self._buttonSize * 2 )

    local gripScale = self._viewSize / ( self._scrollSize + self._viewSize )
    local gripSize = Max( trackSize * gripScale, 10 )

    self._scrollPos = self._buttonSize + offset * ( trackSize - gripSize + 1 )
    self._gripSize = gripSize
end

function VScrollBar:Render( x, y, w, h )
    SetColor( COLORS.scroll )
    DrawRect( x, y, w, h )

    if self.isDragging then
        Panel.RenderPressed( self, x, y + self._scrollPos, w, self._gripSize )
    else
        Panel.Render( self, x, y + self._scrollPos, w, self._gripSize )
    end
end

function VScrollBar:OnMousePress( _, y )
    local _, ly = self:ScreenToLocal( 0, y )

    if ly < self._scrollPos then
        self:SetScroll( self._scroll - self._scrollSize * 0.25 )

    elseif ly > self._scrollPos + self._gripSize then
        self:SetScroll( self._scroll + self._scrollSize * 0.25 )

    else
        self.isDragging = true
        self._grabPos = y
        self._grabScroll = self._scroll
    end

    return true
end

function VScrollBar:OnMouseDrag( _, y )
    if self._grabPos then
        y = y - self._grabPos

        local track = self.h - self._buttonSize * 2 - self._gripSize
        self:SetScroll( self._grabScroll + ( y / track ) * self._scrollSize )
    end
end

function VScrollBar:OnMouseRelease()
    self.isDragging = false
    self._grabPos = nil
    self._grabScroll = nil
end

function VScrollBar:OnMouseWheel( delta )
    self:SetScroll( self._scroll - delta * 30 )

    return true
end

-------- Horizontal Scroll Bar --------

local HScrollBar = WinGUI:Register( "HScrollBar", "VScrollBar" )

function HScrollBar:Setup()
    self.h = 16
    self.offset = 0
    self.isDragging = false

    self._scroll = 0
    self._viewSize = 1
    self._scrollSize = 2
    self._scrollPos = 0
    self._gripSize = 0
    self._buttonSize = 16

    local leftButton = WinGUI:Create( "Button", self )
    leftButton.w = self._buttonSize
    leftButton.h = self._buttonSize
    leftButton.text = "3"
    leftButton.font = FONTS.icons
    leftButton:SetContentAlignment( CONTENT_ALIGN.CENTER )

    local rightButton = WinGUI:Create( "Button", self )
    rightButton.w = self._buttonSize
    rightButton.h = self._buttonSize
    rightButton.text = "4"
    rightButton.font = FONTS.icons
    rightButton:SetContentAlignment( CONTENT_ALIGN.CENTER )

    leftButton.OnClick = function()
        self:SetScroll( self._scroll - 25 )
    end

    rightButton.OnClick = function()
        self:SetScroll( self._scroll + 25 )
    end

    self.leftButton = leftButton
    self.rightButton = rightButton
end

function HScrollBar:PerformLayout()
    self.rightButton.x = self.w - self._buttonSize

    local offset = self._scroll / self._scrollSize
    local trackSize = self.w - ( self._buttonSize * 2 )

    local gripScale = self._viewSize / ( self._scrollSize + self._viewSize )
    local gripSize = Max( trackSize * gripScale, 10 )

    self._scrollPos = self._buttonSize + offset * ( trackSize - gripSize + 1 )
    self._gripSize = gripSize
end

function HScrollBar:Render( x, y, w, h )
    SetColor( COLORS.scroll )
    DrawRect( x, y, w, h )

    if self.isDragging then
        Panel.RenderPressed( self, x + self._scrollPos, y, self._gripSize, h )
    else
        Panel.Render( self, x + self._scrollPos, y, self._gripSize, h )
    end
end

function HScrollBar:OnMousePress( x, _ )
    local lx = self:ScreenToLocal( x, 0 )

    if lx < self._scrollPos then
        self:SetScroll( self._scroll - self._scrollSize * 0.25 )

    elseif lx > self._scrollPos + self._gripSize then
        self:SetScroll( self._scroll + self._scrollSize * 0.25 )

    else
        self.isDragging = true
        self._grabPos = x
        self._grabScroll = self._scroll
    end

    return true
end

function HScrollBar:OnMouseDrag( x, _ )
    if self._grabPos then
        x = x - self._grabPos

        local track = self.w - self._buttonSize * 2 - self._gripSize
        self:SetScroll( self._grabScroll + ( x / track ) * self._scrollSize )
    end
end

-------- Vertical Scroll Panel --------

local VScrollPanel = WinGUI:Register( "VScrollPanel", "Panel" )

function VScrollPanel:Setup()
    self:DockPadding( 0, 4, 16, 0 )

    self._canvas = WinGUI:Create( "Panel", self )
    self._canvas.h = 500
    self._canvas:DockPadding( 4, 4, 3, 4 )
    self._canvas.Render = NOOP

    self._vbar = WinGUI:Create( "VScrollBar", self )
    self._vbar.OnScroll = function( offset )
        self._canvas.y = -offset
    end

    self._canvas.OnMouseWheel = function( _, delta )
        self._vbar:OnMouseWheel( delta )
        return true
    end
end

--- Create a panel inside of the scroll area.
function VScrollPanel:Add( class )
    return WinGUI:Create( class, self._canvas )
end

function VScrollPanel:SizeToChildren()
    self._canvas:SizeToChildren( false, true )
    self:InvalidateLayout()
end

function VScrollPanel:PerformLayout()
    local scrollW = self._vbar.w

    self._canvas.w = self.w - scrollW
    self._vbar.x = self.w - scrollW
    self._vbar.y = 2
    self._vbar.h = self.h - 3

    self._vbar:SetCanvas( self.h, self._canvas.h )
end

function VScrollPanel:Render( x, y, w, h )
    PushClipping( x + 2, y + 2, w - 2, h - 2 )
end

function VScrollPanel:PostRender()
    PopClipping()
end

-------- Simple List --------

local SimpleList = WinGUI:Register( "SimpleList", "Panel" )

function SimpleList:Setup()
    self._rowWidth = 0
    self._rowHeight = 16

    self:Clear()
    self:DockPadding( 4, 4, 4, 4 )
end

function SimpleList:Clear()
    Panel.Clear( self )

    self._rows = {}
    self._selected = nil

    self._vbar = nil
    self._scroll = 0
end

function SimpleList:AddLine( text, shouldSelect )
    local index = #self._rows + 1

    self._rows[index] = text
    self._isLayoutInvalid = true

    if shouldSelect then
        self:SelectLine( index )
    end
end

function SimpleList:SelectLine( index )
    self._selected = index

    if index and self._rows[index] and self.OnSelect then
        self.OnSelect( index, self._rows[index] )
    end
end

function SimpleList:PerformLayout()
    -- margins
    local ml, mt, mr, mb = 0, 0, 0, 0

    if self._dockPadding then
        ml = self._dockPadding.l
        mt = self._dockPadding.t
        mr = self._dockPadding.r
        mb = self._dockPadding.b
    end

    local totalHeight = mt + mb + ( self._rowHeight * #self._rows )

    if totalHeight < self.h then
        self._rowWidth = self.w - ml - mr

        if WinGUI:IsValid( self._vbar ) then
            self._vbar:Remove()
            self._vbar = nil
            self._scroll = 0
        end

        return
    end

    if not self._vbar then
        self._vbar = WinGUI:Create( "VScrollBar", self )

        self._vbar.OnScroll = function( offset )
            self._scroll = -offset
        end
    end

    local scrollW = self._vbar.w

    self._rowWidth = self.w - scrollW - ml - mr
    self._vbar.x = self.w - scrollW
    self._vbar.y = 2
    self._vbar.h = self.h - 3

    self._vbar:SetCanvas( self.h, totalHeight )

    if self._selected then
        self._vbar:SetScroll( self._rowHeight * ( self._selected - 1 ) )
    end
end

function SimpleList:OnMouseWheel( delta )
    if self._vbar then
        self._vbar:OnMouseWheel( delta )
    end

    return true
end

function SimpleList:Render( x, y, w, h )
    Panel.RenderInput( self, x, y, w + 1, h )

    PushClipping( x + 2, y + 2, w - 2, h - 4 )
    SetFont( FONTS.text )

    if self._dockPadding then
        x = x + self._dockPadding.l
        y = y + self._dockPadding.t
    end

    local roww = self._rowWidth
    local rowh = self._rowHeight
    local rowy = 0

    y = y + self._scroll

    for i, row in ipairs( self._rows ) do
        rowy = rowh * ( i - 1 )

        if i == self._selected then
            SetColor( COLORS.primary )
            DrawRect( x, y + rowy, roww, rowh )
            SetColor( COLORS.white )
        else
            SetColor( COLORS.black )
        end

        DrawSimpleText( x + 2, y + rowy + ( rowh * 0.5 ), row, TEXT_ALIGN.LEFT, TEXT_ALIGN.CENTER )
    end

    PopClipping()
end

function SimpleList:OnMousePress( _, y )
    local _, ly = self:ScreenToLocal( 0, y )
    local mt = self._dockPadding and self._dockPadding.t or 0

    ly = ly - self._scroll - mt

    local index = Floor( ly / self._rowHeight ) + 1

    if index > 0 and index <= #self._rows then
        self:SelectLine( index )
    end

    return true
end

-------- Property Sheet --------

local PropertySheet = WinGUI:Register( "PropertySheet", "Panel" )

function PropertySheet:Setup()
    self.h = 100

    self:Clear()
    self:DockPadding( 4, 25, 4, 4 )
end

function PropertySheet:Clear()
    Panel.Clear( self )

    self._tabs = {}
    self._panels = {}
    self._currentTab = 1
end

--- Adds a new tab, and returns the panel associated with it.
function PropertySheet:AddTab( label )
    local index = #self._tabs + 1

    local panel = WinGUI:Create( "Panel", self )
    panel:Dock( DOCK.FILL )
    panel:SetVisible( false )
    panel.Render = NOOP

    if index == 1 then
        panel:SetVisible( true )
        self._currentTab = index
    end

    self._tabs[index] = { label = label }
    self._panels[index] = panel

    return panel
end

function PropertySheet:SelectTabByIndex( index )
    if not self._tabs[index] then return end

    self._currentTab = index

    for i, panel in ipairs( self._panels ) do
        panel:SetVisible( i == index )
    end

    if self.OnSwitchTab then
        self.OnSwitchTab( index, self._panels[index] )
    end
end

--- Close a tab by it's index.
function PropertySheet:CloseTabByIndex( index )
    if not self._tabs[index] then return end

    local panel = table.remove( self._panels, index )
    panel:Remove()

    table.remove( self._tabs, index )

    if self._currentTab == index then
        self:SelectTabByIndex( index > 1 and index - 1 or index + 1 )
    end
end

--- Close a tab by it's panel.
function PropertySheet:CloseTabByPanel( panel )
    for i, p in ipairs( self._panels ) do
        if p == panel then
            self:CloseTabByIndex( i )
            break
        end
    end
end

function PropertySheet:OnMousePress( x, y )
    local lx, ly = self:ScreenToLocal( x, y )
    if ly > 21 then return end

    local tabX = 0

    for i, tab in ipairs( self._tabs ) do
        tabX = tabX + tab.w

        if lx < tabX then
            self:SelectTabByIndex( i )
            break
        end
    end
end

local function DrawTab( label, x, y, w, h, isSelected )
    y = isSelected and y or y + 2
    h = isSelected and h or h - 2

    SetColor( COLORS.black )
    DrawRect( x, y, w, h - 1 )

    SetColor( COLORS.white )
    DrawRect( x, y, w - 1, h - 1 )

    SetColor( COLORS.darkGray )
    DrawRect( x + 1, y + 1, w - 2, h - 2 )

    SetColor( COLORS.lightGray )
    DrawRect( x + 1, y + 1, w - 3, isSelected and h or h - 2 )

    SetColor( COLORS.black )
    DrawSimpleText( x + w * 0.5, y + 2, label, TEXT_ALIGN.CENTER )
end

function PropertySheet:Render( x, y, w, h )
    local tabH = 21

    SetColor( COLORS.white )
    DrawRect( x, y + tabH - 1, w - 1, tabH )
    SetFont( FONTS.text )

    local tabX = x

    for i, tab in ipairs( self._tabs ) do
        if not tab.w then
            tab.w = GetTextSize( tab.label )
            tab.w = tab.w + 10
        end

        DrawTab( tab.label, tabX, y, tab.w, tabH, i == self._currentTab )

        tabX = tabX + tab.w
    end

    y = y + tabH
    h = h - tabH

    SetColor( COLORS.black )
    DrawRect( x, y, w, h )

    SetColor( COLORS.white )
    DrawRect( x, y, w - 1, h - 1 )

    SetColor( COLORS.darkGray )
    DrawRect( x + 1, y, w - 2, h - 1 )

    SetColor( COLORS.lightGray )
    DrawRect( x + 1, y, w - 3, h - 2 )
end

-------- Window --------

local Window = WinGUI:Register( "Window", "Panel" )

function Window:Setup()
    self.w = 200
    self.h = 100
    self.moveable = true
    self.resizable = true
    self.minWidth = 200
    self.minHeight = 100
    self:DockPadding( 4, 24, 4, 4 )

    self._maximized = false

    local titleBar = WinGUI:Create( "Label", self )
    titleBar.x = 3
    titleBar.y = 3
    titleBar.w = self.w - 6
    titleBar.h = 18
    titleBar.text = "Window"
    titleBar.font = FONTS.title
    titleBar.textColor = COLORS.white
    titleBar.backgroundColor = COLORS.darkGray
    titleBar:SetContentAlignment( CONTENT_ALIGN.MIDDLE_LEFT, 2 )

    self.titleBar = titleBar
end

--- Set this window's title.
function Window:SetTitle( title )
    self.titleBar.text = title
end

--- Should this window show a close button?
function Window:SetCloseable( closeable )
    if WinGUI:IsValid( self._closeButton ) then
        self._closeButton:Remove()
        self._closeButton = nil
    end

    if not closeable then return end

    local closeButton = WinGUI:Create( "Button", self )
    closeButton.w = 16
    closeButton.h = 14
    closeButton.text = "r"
    closeButton.font = FONTS.icons
    closeButton:SetContentAlignment( CONTENT_ALIGN.CENTER )

    closeButton.OnClick = function()
        self:Close()
    end

    self._closeButton = closeButton
    self:InvalidateLayout()
end

--- Should this window show a minimize/maximize button?
function Window:SetMaximizable( maximizable )
    if WinGUI:IsValid( self._maximizeButton ) then
        self._maximizeButton:Remove()
        self._maximizeButton = nil
    end

    if not maximizable then return end

    local maximizeButton = WinGUI:Create( "Button", self )
    maximizeButton.w = 16
    maximizeButton.h = 14
    maximizeButton.text = "1"
    maximizeButton.font = FONTS.icons
    maximizeButton:SetContentAlignment( CONTENT_ALIGN.CENTER )

    maximizeButton.OnClick = function()
        self:SetMaximized( not self._maximized )
    end

    self._maximizeButton = maximizeButton
    self:InvalidateLayout()
end

function Window:SetMaximized( maximized )
    if maximized then
        self._lastX = self.x
        self._lastY = self.y
        self._lastW = self.w
        self._lastH = self.h

        self:SetDimensions( 0, 0, self._parent.w, self._parent.h )

        self._maximizeButton.text = "2"
        self._maximized = true
    else
        self._maximized = false
        self._maximizeButton.text = "1"
        self:SetDimensions( self._lastX, self._lastY, self._lastW, self._lastH )

        self._lastW = nil
        self._lastH = nil
        self._lastX = nil
        self._lastY = nil
    end
end

function Window:Center()
    if self._maximized then
        self:SetMaximized( false )
    end

    self.x = Floor( ( self._parent.w * 0.5 ) - ( self.w * 0.5 ) )
    self.y = Floor( ( self._parent.h * 0.5 ) - ( self.h * 0.5 ) )
end

function Window:IsBeingMoved()
    return self._grabOffsetX ~= nil
end

function Window:IsBeingResized()
    return self._resizeStartX ~= nil
end

function Window:PerformLayout()
    local minX, minY, maxX, maxY = self:GetBoundsFromParent()

    -- reduce our min. width/height if our parent is too small
    self.minWidth = math.min( self.minWidth, maxX - minX )
    self.minHeight = math.min( self.minHeight, maxY - minY )

    -- stay inside our parent
    self.x = Clamp( self.x, minX, maxX - self.w )
    self.y = Clamp( self.y, minY, maxY - self.h )
    self.w = Clamp( self.w, self.minWidth, maxX - self.x )
    self.h = Clamp( self.h, self.minHeight, maxY - self.y )

    local buttonX = self.w - 21
    local buttonY = self._maximized and 3 or 5

    if self._maximized then
        self.titleBar.x = 0
        self.titleBar.y = 0
        self.titleBar.w = self.w
        self.titleBar.h = 20
    else
        self.titleBar.x = 3
        self.titleBar.y = 3
        self.titleBar.w = self.w - 6
        self.titleBar.h = 18
    end

    if self._closeButton then
        self._closeButton.x = buttonX
        self._closeButton.y = buttonY
    end

    if self._maximizeButton then
        buttonX = buttonX - 18

        self._maximizeButton.x = buttonX
        self._maximizeButton.y = buttonY

        -- the "maximized" icon/character is slightly misaligned, this is a workaround
        self._maximizeButton:SetContentAlignment( CONTENT_ALIGN[self._maximized and "TOP_CENTER" or "CENTER"] )
    end
end

function Window:OnMousePress( x, y )
    local lx, ly = self:ScreenToLocal( x, y )

    if ly < 20 then
        if self.moveable then
            if self._maximized then
                self:SetMaximized( false )

                local relativeX = self._parent:ScreenToLocal( x, 0 )
                lx = relativeX - lx + self.w * 0.5
            end

            self._grabOffsetX = lx
            self._grabOffsetY = ly
        end

    elseif self.resizable and not self._maximized then
        local isAtRight = lx > self.w - 8
        local isAtBottom = ly > self.h - 8

        if isAtRight then
            self._resizeStartW = self.w
            self._resizeStartX = x
        end

        if isAtBottom then
            self._resizeStartH = self.h
            self._resizeStartY = y
        end
    end

    self:MakePopup()

    return true
end

function Window:OnMouseDrag( x, y )
    local lx, ly = self._parent:ScreenToLocal( x, y )

    if self._grabOffsetX then
        self:SetDimensions( lx - self._grabOffsetX, ly - self._grabOffsetY, self.w, self.h )
    end

    if self._resizeStartX then
        local w = Max( self.minWidth, self._resizeStartW - ( self._resizeStartX - x ) )
        self:SetDimensions( self.x, self.y, w, self.h )
    end

    if self._resizeStartY then
        local h = Max( self.minHeight, self._resizeStartH - ( self._resizeStartY - y ) )
        self:SetDimensions( self.x, self.y, self.w, h )
    end

    if self.OnResize and self._resizeStartX and self._resizeStartY then
        self:OnResize()
    end
end

function Window:OnMouseRelease()
    self._grabOffsetX = nil
    self._grabOffsetY = nil

    self._resizeStartW = nil
    self._resizeStartX = nil
    self._resizeStartH = nil
    self._resizeStartY = nil
end

--- Bring a window to the front.
function Window:MakePopup()
    if self._focused then return end

    Panel.MakePopup( self, true )

    self:OnFocus()
end

function Window:OnFocus()
    self._focused = true
    self.titleBar.backgroundColor = COLORS.primary
end

function Window:OnUnfocus()
    self._focused = false
    self.titleBar.backgroundColor = COLORS.darkGray
end

function Window:Close()
    if self.OnClose then
        self:OnClose()
    end

    self:Remove()
end

-------- Text Entry --------

local ALPHANUM_KEYS = {
    [KEY.A] = "a",
    [KEY.B] = "b",
    [KEY.C] = "c",
    [KEY.D] = "d",
    [KEY.E] = "e",
    [KEY.F] = "f",
    [KEY.G] = "g",
    [KEY.H] = "h",
    [KEY.I] = "i",
    [KEY.J] = "j",
    [KEY.K] = "k",
    [KEY.L] = "l",
    [KEY.M] = "m",
    [KEY.N] = "n",
    [KEY.O] = "o",
    [KEY.P] = "p",
    [KEY.Q] = "q",
    [KEY.R] = "r",
    [KEY.S] = "s",
    [KEY.T] = "t",
    [KEY.U] = "u",
    [KEY.V] = "v",
    [KEY.W] = "w",
    [KEY.X] = "x",
    [KEY.Y] = "y",
    [KEY.Z] = "z",
    [KEY.KEY1] = "1",
    [KEY.KEY2] = "2",
    [KEY.KEY3] = "3",
    [KEY.KEY4] = "4",
    [KEY.KEY5] = "5",
    [KEY.KEY6] = "6",
    [KEY.KEY7] = "7",
    [KEY.KEY8] = "8",
    [KEY.KEY9] = "9",
    [KEY.KEY0] = "0",
    [KEY.SPACE] = " ",
    [KEY.MINUS] = "-",
    [KEY.EQUAL] = "=",
    [KEY.LBRACKET] = "[",
    [KEY.RBRACKET] = "]",
    [KEY.BACKSLASH] = "\\",
    [KEY.SEMICOLON] = ";",
    [KEY.APOSTROPHE] = "'",
    [KEY.BACKQUOTE] = "`",
    [KEY.COMMA] = ",",
    [KEY.PERIOD] = ".",
    [KEY.SLASH] = "/"
}

local SHIFTED_KEYS = {
    [KEY.KEY1] = "!",
    [KEY.KEY2] = "@",
    [KEY.KEY3] = "#",
    [KEY.KEY4] = "$",
    [KEY.KEY5] = "%",
    [KEY.KEY6] = "^",
    [KEY.KEY7] = "&",
    [KEY.KEY8] = "*",
    [KEY.KEY9] = "(",
    [KEY.KEY0] = ")",
    [KEY.MINUS] = "_",
    [KEY.EQUAL] = "+",
    [KEY.LBRACKET] = "{",
    [KEY.RBRACKET] = "}",
    [KEY.BACKSLASH] = "|",
    [KEY.SEMICOLON] = ":",
    [KEY.APOSTROPHE] = "\"",
    [KEY.BACKQUOTE] = "~",
    [KEY.COMMA] = "<",
    [KEY.PERIOD] = ">",
    [KEY.SLASH] = "?"
}

local TextEntry = WinGUI:Register( "TextEntry", "Panel" )

function TextEntry:Setup()
    self.value = ""
    self.font = FONTS.text
    self.textColor = Color( 0, 0, 0 )
    self.backgroundColor = COLORS.white
    self.maxCharacters = 100
    self.placeholder = ""

    self.h = 21
    self._offset = 0
end

-- Try to find where the caret should go at a certain position,
-- in a way that works for non-monospaced fonts.
local function GetCaretPos( x, text )
    local len = text:len()
    local caret, w = 0, 0

    -- If its after the total text width then just
    -- return the max. possible position right away.
    w = GetTextSize( text )
    if x > w then return len end

    -- Otherwise test each character until the text
    -- width gets close to the the position.
    while caret < len do
        caret = caret + 1
        w = GetTextSize( text:sub( 1, caret ) )

        if w >= x then break end
    end

    return Clamp( caret - 1, 0, len )
end

function TextEntry:Render( x, y, w, h )
    Panel.RenderInput( self, x, y, w, h, self.backgroundColor )

    x = x + 4
    y = y - 1
    w = w - 8

    PushClipping( x - 1, y, w + 2, h )
    SetFont( self.font )

    local len = self.value:len()

    if self._clickPos then
        if len == 0 then
            self._caret = 0
        else
            self._caret = GetCaretPos( self._clickPos, self.value )
        end

        self._clickPos = nil
    end

    if len > 0 then
        SetColor( self.textColor )
        DrawSimpleText( x - self._offset, y + h * 0.5, self.value, TEXT_ALIGN.LEFT, TEXT_ALIGN.CENTER )
    else
        SetColor( COLORS.darkGray )
        DrawSimpleText( x, y + h * 0.5, self.placeholder, TEXT_ALIGN.LEFT, TEXT_ALIGN.CENTER )
    end

    PopClipping()

    if not self._caret then return end

    local tw = GetTextSize( self.value:sub( 1, self._caret ) )
    local caretX = tw - self._offset

    if caretX > w then
        self._offset = tw - w

    elseif caretX < 16 then
        self._offset = Max( self._offset - math.abs( caretX ), 0 )
    end

    if RealTime() % 1 > 0.5 then
        SetColor( COLORS.black )
        DrawRect( x + caretX, y + 6, 1, 12 )
    end
end

function TextEntry:OnMousePress( x )
    WinGUI:FocusOnEntry( self )

    local lx = self:ScreenToLocal( x, 0 )
    self._clickPos = lx + self._offset
end

function TextEntry:OnFocus()
    self._caret = self.value:len()
end

function TextEntry:OnUnfocus()
    self._caret = nil
end

function TextEntry:InsertAt( pos, char )
    pos = pos or 0

    local l, r = "", ""

    if pos > 0 then
        l = string.sub( self.value, 1, pos - 1 )
        r = string.sub( self.value, pos )
    end

    self.value = l .. char .. r

    if self.OnChange then
        self.OnChange( self.value )
    end
end

function TextEntry:OnKeyPress( key )
    local len = self.value:len()

    if key == KEY.LEFT and self._caret > 0 then
        self._caret = self._caret - 1

    elseif key == KEY.RIGHT and self._caret < len then
        self._caret = self._caret + 1
    end

    if key == KEY.ENTER and len > 0 then
        if self.OnEnter then
            self.OnEnter( self.value )
        end

        return
    end

    if key == KEY.BACKSPACE and len > 0 and self._caret > 0 then
        self._caret = Clamp( self._caret - 1, 0, self.value:len() )

        local l = self.value:sub( 1, self._caret )
        local r = self.value:sub( self._caret + 2 )

        self.value = l .. r

        if self.OnChange then
            self.OnChange( self.value )
        end

        return
    end

    local char = ALPHANUM_KEYS[key]

    if not char then return end
    if len >= self.maxCharacters then return end

    if input.isShiftDown() then
        char = SHIFTED_KEYS[key] or char:upper()
    end

    self._caret = self._caret + 1
    self:InsertAt( self._caret, char )
end

return WinGUI
